---
status: pending
parallelizable: false
blocked_by: ["9.0", "10.0"]
---

<task_context>
<domain>testing/unit</domain>
<type>testing</type>
<scope>quality_assurance</scope>
<complexity>medium</complexity>
<dependencies>user_service,role_service</dependencies>
<unblocks>12.0,16.0</unblocks>
</task_context>

# Tarefa 11.0: Testes Unitários de Serviços

## Visão Geral

Implementar testes unitários para `UserService` e `RoleService`, garantindo cobertura de casos felizes, edge cases e cenários de erro. Os testes usarão mocks do `UserManager` e `SignInManager` para isolar a lógica de negócio.

## Contexto da Tech Spec

**Referência:** Seção 9.1 da Tech Spec - Estrutura de Testes

Testes a implementar:
- **UserService**: registro, login, 2FA, setup de authenticator
- **RoleService**: atribuição de roles, obtenção de roles
- **Edge cases**: usuário não encontrado, credenciais inválidas, role inválida
- **Mocking**: UserManager, SignInManager, RoleManager

## Requisitos

- [ ] Criar projeto de testes unitários (se não existir)
- [ ] Adicionar pacotes de teste (xUnit, Moq, FluentAssertions)
- [ ] Implementar testes para `UserService`
- [ ] Implementar testes para `RoleService`
- [ ] Implementar testes para `AuthorizationPolicies` (opcional)
- [ ] Atingir cobertura > 80% em serviços
- [ ] Todos os testes passando

## Subtarefas

### 11.1: Configurar Projeto de Testes

**Ação:** Criar/configurar projeto de testes unitários

**Comandos:**
```bash
cd tests/MathFlow.UnitTests

# Se projeto não existe, criar
dotnet new xunit -n MathFlow.UnitTests

# Adicionar referência ao projeto principal
dotnet add reference ../../src/MathFlow/MathFlow.csproj

# Adicionar pacotes de teste
dotnet add package Moq --version 4.20.70
dotnet add package FluentAssertions --version 6.12.0
dotnet add package Microsoft.Extensions.Logging.Abstractions --version 9.0.0
```

**Validação:**
- [ ] Projeto de testes configurado
- [ ] Referência ao projeto principal adicionada
- [ ] Pacotes Moq e FluentAssertions instalados

### 11.2: Criar Classe Base para Testes

**Ação:** Criar classe helper para configurar mocks comuns

**Arquivo:** `tests/MathFlow.UnitTests/Identity/IdentityTestBase.cs`

**Código:**
```csharp
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Logging;
using Moq;
using MathFlow.Infrastructure.IdentityServer.Models;

namespace MathFlow.UnitTests.Identity;

public abstract class IdentityTestBase
{
    protected Mock<UserManager<ApplicationUser>> CreateMockUserManager()
    {
        var store = new Mock<IUserStore<ApplicationUser>>();
        var userManager = new Mock<UserManager<ApplicationUser>>(
            store.Object, null, null, null, null, null, null, null, null);
        return userManager;
    }

    protected Mock<SignInManager<ApplicationUser>> CreateMockSignInManager(
        Mock<UserManager<ApplicationUser>> userManager)
    {
        var contextAccessor = new Mock<Microsoft.AspNetCore.Http.IHttpContextAccessor>();
        var claimsFactory = new Mock<IUserClaimsPrincipalFactory<ApplicationUser>>();
        
        var signInManager = new Mock<SignInManager<ApplicationUser>>(
            userManager.Object,
            contextAccessor.Object,
            claimsFactory.Object,
            null, null, null, null);
        
        return signInManager;
    }

    protected Mock<ILogger<T>> CreateMockLogger<T>()
    {
        return new Mock<ILogger<T>>();
    }
}
```

**Validação:**
- [ ] Classe base criada
- [ ] Métodos helper para criar mocks
- [ ] Namespace correto

### 11.3: Implementar Testes de UserService

**Ação:** Criar testes para UserService

**Arquivo:** `tests/MathFlow.UnitTests/Identity/UserServiceTests.cs`

**Código:**
```csharp
using FluentAssertions;
using Microsoft.AspNetCore.Identity;
using Moq;
using MathFlow.Application.Services.Identity;
using MathFlow.Infrastructure.IdentityServer.Models;

namespace MathFlow.UnitTests.Identity;

public class UserServiceTests : IdentityTestBase
{
    [Fact]
    public async Task RegisterUserAsync_ShouldCreateUserWithNormalRole()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var signInManager = CreateMockSignInManager(userManager);
        var logger = CreateMockLogger<UserService>();

        userManager.Setup(x => x.CreateAsync(It.IsAny<ApplicationUser>(), It.IsAny<string>()))
            .ReturnsAsync(IdentityResult.Success);
        
        userManager.Setup(x => x.AddToRoleAsync(It.IsAny<ApplicationUser>(), "normal"))
            .ReturnsAsync(IdentityResult.Success);

        var service = new UserService(userManager.Object, signInManager.Object, logger.Object);

        // Act
        var result = await service.RegisterUserAsync("test@example.com", "Password@123", "testuser");

        // Assert
        result.Succeeded.Should().BeTrue();
        userManager.Verify(x => x.CreateAsync(
            It.Is<ApplicationUser>(u => 
                u.Email == "test@example.com" && 
                u.TwoFactorEnabled == true), 
            "Password@123"), Times.Once);
        userManager.Verify(x => x.AddToRoleAsync(It.IsAny<ApplicationUser>(), "normal"), Times.Once);
    }

    [Fact]
    public async Task RegisterUserAsync_ShouldReturnFailure_WhenCreationFails()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var signInManager = CreateMockSignInManager(userManager);
        var logger = CreateMockLogger<UserService>();

        var errors = new[] { new IdentityError { Description = "Password too weak" } };
        userManager.Setup(x => x.CreateAsync(It.IsAny<ApplicationUser>(), It.IsAny<string>()))
            .ReturnsAsync(IdentityResult.Failed(errors));

        var service = new UserService(userManager.Object, signInManager.Object, logger.Object);

        // Act
        var result = await service.RegisterUserAsync("test@example.com", "weak", "testuser");

        // Assert
        result.Succeeded.Should().BeFalse();
        result.Errors.Should().ContainSingle(e => e.Description == "Password too weak");
    }

    [Fact]
    public async Task LoginAsync_ShouldReturnTwoFactorRequired_WhenUserHas2FAEnabled()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var signInManager = CreateMockSignInManager(userManager);
        var logger = CreateMockLogger<UserService>();

        var user = new ApplicationUser 
        { 
            Email = "test@example.com", 
            TwoFactorEnabled = true 
        };

        userManager.Setup(x => x.FindByEmailAsync("test@example.com"))
            .ReturnsAsync(user);
        
        userManager.Setup(x => x.GetTwoFactorEnabledAsync(user))
            .ReturnsAsync(true);
        
        userManager.Setup(x => x.CheckPasswordAsync(user, "Password@123"))
            .ReturnsAsync(true);

        var service = new UserService(userManager.Object, signInManager.Object, logger.Object);

        // Act
        var result = await service.LoginAsync("test@example.com", "Password@123", false);

        // Assert
        result.RequiresTwoFactor.Should().BeTrue();
    }

    [Fact]
    public async Task LoginAsync_ShouldReturnFailed_WhenUserNotFound()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var signInManager = CreateMockSignInManager(userManager);
        var logger = CreateMockLogger<UserService>();

        userManager.Setup(x => x.FindByEmailAsync(It.IsAny<string>()))
            .ReturnsAsync((ApplicationUser)null);

        var service = new UserService(userManager.Object, signInManager.Object, logger.Object);

        // Act
        var result = await service.LoginAsync("nonexistent@example.com", "Password@123", false);

        // Assert
        result.Succeeded.Should().BeFalse();
    }

    [Fact]
    public async Task VerifyTwoFactorCodeAsync_ShouldReturnTrue_WhenCodeIsValid()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var signInManager = CreateMockSignInManager(userManager);
        var logger = CreateMockLogger<UserService>();

        var user = new ApplicationUser { Email = "test@example.com" };

        userManager.Setup(x => x.FindByEmailAsync("test@example.com"))
            .ReturnsAsync(user);
        
        userManager.Setup(x => x.VerifyTwoFactorTokenAsync(
            user, 
            It.IsAny<string>(), 
            "123456"))
            .ReturnsAsync(true);
        
        signInManager.Setup(x => x.SignInAsync(user, true, null))
            .Returns(Task.CompletedTask);

        var service = new UserService(userManager.Object, signInManager.Object, logger.Object);

        // Act
        var result = await service.VerifyTwoFactorCodeAsync("test@example.com", "123456");

        // Assert
        result.Should().BeTrue();
        signInManager.Verify(x => x.SignInAsync(user, true, null), Times.Once);
    }

    [Fact]
    public async Task GetTwoFactorSetupKeyAsync_ShouldGenerateKey_WhenNotExists()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var signInManager = CreateMockSignInManager(userManager);
        var logger = CreateMockLogger<UserService>();

        var user = new ApplicationUser { Id = "user123" };

        userManager.Setup(x => x.FindByIdAsync("user123"))
            .ReturnsAsync(user);
        
        userManager.Setup(x => x.GetAuthenticatorKeyAsync(user))
            .ReturnsAsync((string)null);
        
        userManager.Setup(x => x.ResetAuthenticatorKeyAsync(user))
            .ReturnsAsync(IdentityResult.Success);
        
        userManager.SetupSequence(x => x.GetAuthenticatorKeyAsync(user))
            .ReturnsAsync((string)null)
            .ReturnsAsync("NEWKEY123");

        var service = new UserService(userManager.Object, signInManager.Object, logger.Object);

        // Act
        var key = await service.GetTwoFactorSetupKeyAsync("user123");

        // Assert
        key.Should().Be("NEWKEY123");
        userManager.Verify(x => x.ResetAuthenticatorKeyAsync(user), Times.Once);
    }
}
```

**Validação:**
- [ ] 6+ testes implementados para UserService
- [ ] Casos felizes cobertos
- [ ] Edge cases cobertos (usuário não encontrado, senha inválida)
- [ ] Uso correto de mocks e assertions

### 11.4: Implementar Testes de RoleService

**Ação:** Criar testes para RoleService

**Arquivo:** `tests/MathFlow.UnitTests/Identity/RoleServiceTests.cs`

**Código:**
```csharp
using FluentAssertions;
using Microsoft.AspNetCore.Identity;
using Moq;
using MathFlow.Application.Services.Identity;
using MathFlow.Infrastructure.IdentityServer.Models;

namespace MathFlow.UnitTests.Identity;

public class RoleServiceTests : IdentityTestBase
{
    [Fact]
    public async Task AssignRoleAsync_ShouldAssignRole_WhenUserExists()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var logger = CreateMockLogger<RoleService>();

        var user = new ApplicationUser { Id = "user123", Email = "test@example.com" };

        userManager.Setup(x => x.FindByIdAsync("user123"))
            .ReturnsAsync(user);
        
        userManager.Setup(x => x.GetRolesAsync(user))
            .ReturnsAsync(new List<string> { "normal" });
        
        userManager.Setup(x => x.RemoveFromRolesAsync(user, It.IsAny<IEnumerable<string>>()))
            .ReturnsAsync(IdentityResult.Success);
        
        userManager.Setup(x => x.AddToRoleAsync(user, "premium"))
            .ReturnsAsync(IdentityResult.Success);

        var service = new RoleService(userManager.Object, logger.Object);

        // Act
        var result = await service.AssignRoleAsync("user123", "premium");

        // Assert
        result.Succeeded.Should().BeTrue();
        userManager.Verify(x => x.RemoveFromRolesAsync(user, It.Is<IEnumerable<string>>(r => r.Contains("normal"))), Times.Once);
        userManager.Verify(x => x.AddToRoleAsync(user, "premium"), Times.Once);
    }

    [Fact]
    public async Task AssignRoleAsync_ShouldNotRemoveMasterAdminRole()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var logger = CreateMockLogger<RoleService>();

        var user = new ApplicationUser { Id = "user123", Email = "admin@example.com" };

        userManager.Setup(x => x.FindByIdAsync("user123"))
            .ReturnsAsync(user);
        
        userManager.Setup(x => x.GetRolesAsync(user))
            .ReturnsAsync(new List<string> { "masterAdmin", "admin" });
        
        userManager.Setup(x => x.RemoveFromRolesAsync(user, It.IsAny<IEnumerable<string>>()))
            .ReturnsAsync(IdentityResult.Success);
        
        userManager.Setup(x => x.AddToRoleAsync(user, "premium"))
            .ReturnsAsync(IdentityResult.Success);

        var service = new RoleService(userManager.Object, logger.Object);

        // Act
        var result = await service.AssignRoleAsync("user123", "premium");

        // Assert
        result.Succeeded.Should().BeTrue();
        userManager.Verify(x => x.RemoveFromRolesAsync(
            user, 
            It.Is<IEnumerable<string>>(r => r.Contains("admin") && !r.Contains("masterAdmin"))), 
            Times.Once);
    }

    [Fact]
    public async Task AssignRoleAsync_ShouldReturnFailure_WhenUserNotFound()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var logger = CreateMockLogger<RoleService>();

        userManager.Setup(x => x.FindByIdAsync(It.IsAny<string>()))
            .ReturnsAsync((ApplicationUser)null);

        var service = new RoleService(userManager.Object, logger.Object);

        // Act
        var result = await service.AssignRoleAsync("nonexistent", "premium");

        // Assert
        result.Succeeded.Should().BeFalse();
        result.Errors.Should().ContainSingle(e => e.Description == "User not found");
    }

    [Fact]
    public async Task AssignRoleAsync_ShouldReturnFailure_WhenRoleIsInvalid()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var logger = CreateMockLogger<RoleService>();

        var service = new RoleService(userManager.Object, logger.Object);

        // Act
        var result = await service.AssignRoleAsync("user123", "invalidRole");

        // Assert
        result.Succeeded.Should().BeFalse();
        result.Errors.Should().ContainSingle(e => e.Description.Contains("Invalid role"));
    }

    [Fact]
    public async Task GetUserRolesAsync_ShouldReturnRoles_WhenUserExists()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var logger = CreateMockLogger<RoleService>();

        var user = new ApplicationUser { Id = "user123" };

        userManager.Setup(x => x.FindByIdAsync("user123"))
            .ReturnsAsync(user);
        
        userManager.Setup(x => x.GetRolesAsync(user))
            .ReturnsAsync(new List<string> { "premium", "admin" });

        var service = new RoleService(userManager.Object, logger.Object);

        // Act
        var roles = await service.GetUserRolesAsync("user123");

        // Assert
        roles.Should().HaveCount(2);
        roles.Should().Contain("premium");
        roles.Should().Contain("admin");
    }

    [Fact]
    public async Task GetUserRolesAsync_ShouldReturnEmptyList_WhenUserNotFound()
    {
        // Arrange
        var userManager = CreateMockUserManager();
        var logger = CreateMockLogger<RoleService>();

        userManager.Setup(x => x.FindByIdAsync(It.IsAny<string>()))
            .ReturnsAsync((ApplicationUser)null);

        var service = new RoleService(userManager.Object, logger.Object);

        // Act
        var roles = await service.GetUserRolesAsync("nonexistent");

        // Assert
        roles.Should().BeEmpty();
    }
}
```

**Validação:**
- [ ] 6+ testes implementados para RoleService
- [ ] Proteção de masterAdmin testada
- [ ] Casos felizes e edge cases cobertos
- [ ] Uso correto de mocks e assertions

### 11.5: Executar Testes

**Ação:** Executar todos os testes e validar cobertura

**Comandos:**
```bash
cd tests/MathFlow.UnitTests

# Executar testes
dotnet test

# Executar com verbosidade
dotnet test --logger "console;verbosity=detailed"

# Gerar relatório de cobertura (opcional)
dotnet test --collect:"XPlat Code Coverage"
```

**Validação:**
- [ ] Todos os testes passando
- [ ] Zero testes falhando
- [ ] Cobertura > 80% em UserService e RoleService

## Sequenciamento

- **Bloqueado por:** 9.0 (UserService), 10.0 (RoleService)
- **Desbloqueia:** 12.0 (Login/Register Pages), 16.0 (Manage Pages)
- **Paralelizável com:** Nenhum (depende de ambos os serviços)

## Critérios de Aceitação

- [ ] Projeto de testes configurado
- [ ] 12+ testes implementados (6 UserService + 6 RoleService)
- [ ] Todos os testes passando
- [ ] Cobertura > 80% em serviços críticos
- [ ] Uso correto de mocks (UserManager, SignInManager)
- [ ] Assertions claras com FluentAssertions

## Comandos de Validação

```bash
# Executar testes
cd tests/MathFlow.UnitTests
dotnet test

# Contar testes
dotnet test --list-tests | grep -c "MathFlow.UnitTests.Identity"

# Verificar cobertura (se configurado)
dotnet test --collect:"XPlat Code Coverage"
```

## Notas de Implementação

- **Atenção**: Mocking de UserManager é complexo, usar classe base helper
- **Dica**: FluentAssertions torna assertions mais legíveis
- **Importante**: Testar edge cases é tão importante quanto casos felizes
- **Próximo passo**: Após conclusão, implementar páginas de UI (12.0, 16.0)

## Estimativa

**Tempo estimado:** 1 dia (8 horas)

## Riscos

- **Médio**: Dificuldade em mockar UserManager - Mitigação: Usar classe base helper
- **Baixo**: Testes flaky - Mitigação: Evitar dependências de tempo/estado global
- **Baixo**: Cobertura insuficiente - Mitigação: Focar em métodos públicos críticos

## Referências

- [xUnit Documentation](https://xunit.net/)
- [Moq Documentation](https://github.com/moq/moq4)
- [FluentAssertions Documentation](https://fluentassertions.com/)
- [Unit Testing Best Practices](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices)
