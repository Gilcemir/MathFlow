---
status: pending
parallelizable: true
blocked_by: ["1.0"]
---

<task_context>
<domain>backend/observability</domain>
<type>implementation</type>
<scope>telemetry</scope>
<complexity>medium</complexity>
<dependencies>opentelemetry</dependencies>
<unblocks>5.0</unblocks>
</task_context>

# Tarefa 4.0: Implementar OpenTelemetry Completo

## Visão Geral

Implementar OpenTelemetry completo na aplicação: adicionar pacotes NuGet, criar classe `OpenTelemetryConfigurator` que configura OpenTelemetry SDK para coletar logs, traces e métricas, e integrar no `Program.cs`.

## Contexto da Tech Spec

**Referência:** Seção 3.1 da Tech Spec - OpenTelemetryConfigurator

**Responsabilidades:**
- Configurar OpenTelemetry SDK
- Registrar instrumentações (ASP.NET Core, HTTP, Runtime, Process)
- Configurar exporters (OTLP, Console)
- Configurar resource attributes (service name, version)

**Instrumentações:**
- **Logs:** Console + OTLP
- **Traces:** ASP.NET Core + HTTP Client + OTLP
- **Métricas:** ASP.NET Core + Runtime + Process + OTLP

## Requisitos

- [ ] Adicionar 8 pacotes NuGet OpenTelemetry ao .csproj
- [ ] Restaurar dependências
- [ ] Criar classe `OpenTelemetryConfigurator` em `Infrastructure/Observability/`
- [ ] Implementar extension method `AddOpenTelemetry()`
- [ ] Configurar logs estruturados
- [ ] Configurar traces com instrumentações
- [ ] Configurar métricas com instrumentações
- [ ] Configurar exporters OTLP
- [ ] Integrar no `Program.cs`
- [ ] Testar localmente
- [ ] Fallback gracioso se OTLP endpoint indisponível

## Subtarefas

### 4.1: Adicionar Pacotes NuGet

**Ação:** Adicionar todos os pacotes OpenTelemetry ao .csproj

**Arquivo:** `src/MathFlow/MathFlow.csproj`

**Pacotes a adicionar:**
```xml
<ItemGroup>
  <PackageReference Include="OpenTelemetry" Version="1.7.0" />
  <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.7.0" />
  <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.7.0" />
  <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.7.0" />
  <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.7.0" />
  <PackageReference Include="OpenTelemetry.Instrumentation.Process" Version="0.5.0-beta.4" />
  <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.7.0" />
  <PackageReference Include="OpenTelemetry.Exporter.Console" Version="1.7.0" />
</ItemGroup>
```

**Comandos:**
```bash
cd src/MathFlow
dotnet restore
```

**Validação:**
- [ ] Pacotes adicionados ao .csproj
- [ ] `dotnet restore` sem erros

### 4.2: Criar Estrutura de Pastas

**Ação:** Criar pasta para código de observabilidade

**Comandos:**
```bash
mkdir -p src/MathFlow/Infrastructure/Observability
```

**Validação:**
- [ ] Pasta criada

### 4.3: Criar OpenTelemetryConfigurator.cs

**Ação:** Implementar classe com configuração completa

**Arquivo:** `src/MathFlow/Infrastructure/Observability/OpenTelemetryConfigurator.cs`

**Conteúdo:**
```csharp
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MathFlow.Infrastructure.Observability;

/// <summary>
/// Configura OpenTelemetry para coleta de logs, traces e métricas
/// </summary>
public static class OpenTelemetryConfigurator
{
    private const string ServiceName = "MathFlow";
    private const string ServiceVersion = "1.0.0";

    /// <summary>
    /// Adiciona OpenTelemetry ao WebApplicationBuilder
    /// </summary>
    public static WebApplicationBuilder AddOpenTelemetry(this WebApplicationBuilder builder)
    {
        var otlpEndpoint = builder.Configuration["Otlp:Endpoint"];
        
        builder.Services.AddOpenTelemetry()
            .ConfigureResource(ConfigureResource)
            .WithLogging(logging => ConfigureLogging(logging, otlpEndpoint))
            .WithTracing(tracing => ConfigureTracing(tracing, otlpEndpoint))
            .WithMetrics(metrics => ConfigureMetrics(metrics, otlpEndpoint));
        
        return builder;
    }

    /// <summary>
    /// Configura resource attributes (service name, version, etc)
    /// </summary>
    private static void ConfigureResource(ResourceBuilder resource)
    {
        resource
            .AddService(
                serviceName: ServiceName,
                serviceVersion: ServiceVersion)
            .AddTelemetrySdk()
            .AddEnvironmentVariableDetector();
    }

    /// <summary>
    /// Configura exportação de logs
    /// </summary>
    private static void ConfigureLogging(OpenTelemetryLoggerOptions logging, string? otlpEndpoint)
    {
        // Console exporter (sempre ativo para debug local)
        logging.AddConsoleExporter();
        
        // OTLP exporter (se endpoint configurado)
        if (!string.IsNullOrEmpty(otlpEndpoint))
        {
            logging.AddOtlpExporter(opts =>
            {
                opts.Endpoint = new Uri(otlpEndpoint);
                opts.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.Grpc;
            });
        }
    }

    /// <summary>
    /// Configura instrumentação e exportação de traces
    /// </summary>
    private static void ConfigureTracing(TracerProviderBuilder tracing, string? otlpEndpoint)
    {
        tracing
            // Instrumentações
            .AddAspNetCoreInstrumentation(opts =>
            {
                opts.RecordException = true;
                opts.Filter = (httpContext) => 
                {
                    // Ignorar health checks e static files
                    var path = httpContext.Request.Path.Value ?? string.Empty;
                    return !path.Contains("/health") && 
                           !path.Contains("/_framework/");
                };
            })
            .AddHttpClientInstrumentation(opts =>
            {
                opts.RecordException = true;
            });
        
        // OTLP exporter (se endpoint configurado)
        if (!string.IsNullOrEmpty(otlpEndpoint))
        {
            tracing.AddOtlpExporter(opts =>
            {
                opts.Endpoint = new Uri(otlpEndpoint);
                opts.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.Grpc;
            });
        }
    }

    /// <summary>
    /// Configura instrumentação e exportação de métricas
    /// </summary>
    private static void ConfigureMetrics(MeterProviderBuilder metrics, string? otlpEndpoint)
    {
        metrics
            // Meters do ASP.NET Core
            .AddMeter("Microsoft.AspNetCore.Hosting")
            .AddMeter("Microsoft.AspNetCore.Server.Kestrel")
            .AddMeter("Microsoft.AspNetCore.Http.Connections")
            .AddMeter("Microsoft.AspNetCore.Routing")
            .AddMeter("Microsoft.AspNetCore.Diagnostics")
            .AddMeter("Microsoft.AspNetCore.RateLimiting")
            
            // Instrumentações
            .AddAspNetCoreInstrumentation()
            .AddRuntimeInstrumentation()
            .AddProcessInstrumentation();
        
        // OTLP exporter (se endpoint configurado)
        if (!string.IsNullOrEmpty(otlpEndpoint))
        {
            metrics.AddOtlpExporter(opts =>
            {
                opts.Endpoint = new Uri(otlpEndpoint);
                opts.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.Grpc;
            });
        }
    }
}
```

**Validação:**
- [ ] Arquivo criado
- [ ] Código compila sem erros
- [ ] Todos os namespaces corretos

### 4.4: Integrar no Program.cs

**Ação:** Adicionar chamada ao OpenTelemetry no Program.cs

**Arquivo:** `src/MathFlow/Program.cs`

**Modificação:**
```csharp
using Jering.Javascript.NodeJS;
using MathFlow.Infrastructure.Converters;
using MathFlow.Infrastructure.Observability;  // ADICIONAR
using MathFlow.Services;
using MathFlow.Services.Coverters;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorPages();
builder.Services.AddNodeJS();

// ADICIONAR: Configurar OpenTelemetry
builder.AddOpenTelemetry();

builder.Services.Configure<OutOfProcessNodeJSServiceOptions>(options =>
{
    // ... resto do código
```

**Validação:**
- [ ] Using adicionado
- [ ] `builder.AddOpenTelemetry()` chamado
- [ ] Código compila

### 4.5: Testar Compilação

**Ação:** Compilar projeto e verificar erros

**Comandos:**
```bash
cd src/MathFlow
dotnet build
```

**Validação:**
- [ ] Build sem erros
- [ ] Nenhum warning crítico
- [ ] Pacotes NuGet resolvidos

### 4.6: Testar Localmente

**Ação:** Executar aplicação e verificar telemetria

**Comandos:**
```bash
cd src/MathFlow
dotnet run
```

**Validação:**
- [ ] Aplicação inicia sem erros
- [ ] Logs estruturados aparecem no console
- [ ] Nenhum erro relacionado a OpenTelemetry
- [ ] Aplicação funciona normalmente

### 4.7: Criar Teste Unitário Básico (Opcional)

**Ação:** Criar teste para validar configuração

**Arquivo:** `tests/MathFlow.UnitTests/Infrastructure/Observability/OpenTelemetryConfiguratorTests.cs`

**Conteúdo:**
```csharp
using MathFlow.Infrastructure.Observability;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Xunit;

namespace MathFlow.UnitTests.Infrastructure.Observability;

public class OpenTelemetryConfiguratorTests
{
    [Fact]
    public void AddOpenTelemetry_ShouldNotThrow_WhenOtlpEndpointConfigured()
    {
        // Arrange
        var builder = WebApplication.CreateBuilder();
        builder.Configuration["Otlp:Endpoint"] = "http://localhost:4317";
        
        // Act & Assert
        var exception = Record.Exception(() => builder.AddOpenTelemetry());
        Assert.Null(exception);
    }
    
    [Fact]
    public void AddOpenTelemetry_ShouldNotThrow_WhenOtlpEndpointMissing()
    {
        // Arrange
        var builder = WebApplication.CreateBuilder();
        
        // Act & Assert
        var exception = Record.Exception(() => builder.AddOpenTelemetry());
        Assert.Null(exception);
    }
}
```

**Validação:**
- [ ] Teste criado (se tempo permitir)
- [ ] Testes passam

## Sequenciamento

- **Bloqueado por:** 1.0 (Reestruturação)
- **Desbloqueia:** 5.0 (docker-compose completo)
- **Paralelizável:** Sim (com tarefas 2.0, 3.0)

## Critérios de Aceitação

✅ **Pacotes NuGet:**
- 8 pacotes OpenTelemetry adicionados
- `dotnet restore` sem erros

✅ **Classe criada:**
- `OpenTelemetryConfigurator.cs` em `Infrastructure/Observability/`
- Extension method `AddOpenTelemetry()`

✅ **Configuração completa:**
- Logs: Console + OTLP
- Traces: ASP.NET Core + HTTP + OTLP
- Métricas: ASP.NET Core + Runtime + Process + OTLP

✅ **Integração:**
- `Program.cs` atualizado
- `builder.AddOpenTelemetry()` chamado
- Aplicação executa localmente

✅ **Qualidade:**
- Código compila sem erros
- Documentação XML presente
- Fallback gracioso (funciona sem OTLP)
- Testes unitários passam (se criados)

## Riscos e Mitigações

| Risco | Probabilidade | Impacto | Mitigação |
|-------|---------------|---------|-----------|
| Pacotes NuGet incompatíveis | Baixa | Alto | Usar versões testadas |
| Endpoint OTLP inválido | Média | Médio | Validar configuração, fallback gracioso |
| Overhead de performance | Baixa | Médio | Usar sampling se necessário (futuro) |

## Notas de Implementação

- **Tempo estimado:** 3-4 horas
- **Complexidade:** Média
- **Dependências:** Nenhuma (após tarefa 1.0)
- **Teste crítico:** Aplicação deve compilar e executar localmente com telemetria

## Referências

- [OpenTelemetry .NET](https://opentelemetry.io/docs/instrumentation/net/)
- [ASP.NET Core Instrumentation](https://github.com/open-telemetry/opentelemetry-dotnet-contrib/tree/main/src/OpenTelemetry.Instrumentation.AspNetCore)
- Tech Spec Seção 3.1

## Checklist Final

- [ ] Pacotes NuGet adicionados
- [ ] `dotnet restore` executado
- [ ] Pasta `Infrastructure/Observability/` criada
- [ ] `OpenTelemetryConfigurator.cs` implementado
- [ ] `Program.cs` atualizado
- [ ] Código compila sem erros
- [ ] Aplicação executa localmente
- [ ] Telemetria aparece no console
- [ ] Documentação XML presente
- [ ] Testes unitários criados (opcional)
- [ ] Tarefa marcada como completa no `tasks.md`
